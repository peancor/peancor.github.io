<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Representación de campos escalares tridimensionales | la ciudadela</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Representación de campos escalares tridimensionales" />
<meta name="author" content="peancor" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="La representación volumétrica es una técnica que permite la representación de campos escalares tridimensionales. Sus aplicaciones son múltiples: representación de imágenes del cuerpo humano procedentes de diversos instrumentos sensores con fines médicos, representación realista de nubes u otros fenómenos gaseosos en simulaciones visuales en entornos virtuales, o representación de diversas estructuras y constructos en la ciencia y la ingeniería. En este artículo se describirá una variante de la técnica basada en texturas conocida como ‘volume ray casting’. Conceptualmente dicha técnica consiste en el lanzamiento de rayos con origen en la cámara de tal forma que atraviesen el volumen que contiene el campo escalar. El color resultante que se ‘pintará’ en la superficie del volumen en el punto de entrada de cada rayo será una función de los puntos que el rayo atravesó al pasar por el volumen. Para su implementación se utilizará la plataforma XNA y se hará uso de la aceleración grafica que nos proporcionan la GPU. Será necesaria una tarjeta que soporte al menos la versión 3.0 del modelo de sombreadores (Shader Model 3.0). El proceso comienza con la representación de un volumen que actuará como frontera del campo escalar, es decir, el campo escalar se encontrará completamente en el interior de ese volumen. Utilizaremos un cubo. En primer lugar representaremos las posiciones de entrada del rayo y de salida en dos texturas que posteriormente utilizaremos para determinar la dirección. Al Vertex Shader en la GPU se le harán llegar las posiciones sin transformar de los vértices del cubo. Dichas coordenadas se copiaran a la variable InterpolatedPosition a la salida del Vertex Shader. Dicha variable está marcada como coordenadas de textura por lo que a la entrada del pixel shader se recibiran las coordenadas interpoladas. Lo mismo se hará para la variable InterpolatedTransformedPosition solo que en este caso almacenaremos las coordenadas transformadas por la combinación de las matrices de posicionamiento en el mundo (world), vista (view) y proyección (projection) que serán suministradas a la entrada del programa de la GPU como parámetros. Esta última variable será utilizada posteriormente para localizar la posición exacta donde se deben muestrear las texturas para obtener la dirección del rayo.     1 struct VertexShaderInput     2 {     3     float4 Position : POSITION0;     4 };     5     6 struct VertexShaderOutput     7 {     8     float4 Position : POSITION0;     9     float4 InterpolatedPosition : TEXCOORD0;    10     float4 InterpolatedTransformedPosition : TEXCOORD1;    11 };    12    13 VertexShaderOutput VertexShaderFunction(VertexShaderInput input)    14 {    15     VertexShaderOutput output;    16    17     float4 worldPosition = mul(input.Position, World);    18     float4 viewPosition = mul(worldPosition, View);    19     output.Position = mul(viewPosition, Projection);    20     output.InterpolatedPosition = input.Position;    21     output.InterpolatedTransformedPosition = output.Position;    22     return output;    23 }    24    25 float4 RenderPositionsPixelShaderFunction(VertexShaderOutput input) : COLOR0    26 {    27     float4 color = input.InterpolatedPosition;    28     return color;    29 } Se representarán las caras frontales del cubo en una textura utilizando el estado de representación CullMode.CounterClockWise. El color asignado a la textura en realidad contiene las coordenadas tridimensionades del cubo en el espacio de coordenadas local del modelo en el formato (x,y,z,1). A continuación se repite la operación pero esta vez representando las caras interiores del cubo. El siguiente y ultimo paso es la representación del cubo, solo que en esta ocasión el color resultante será función del campo escalar, muestreado en base a las direcciones grabadas en las texturas anteriores. Al muestrear cada una de las texturas anteriores podemos obtener para cada punto (x,y) de la textura, las coordenadas (x,y,z) del cubo por las cuales entró el rayo y por las cuales salió. Con estas dos coordenadas se puede calcular la dirección del rayo y al conocer el punto inicial y la dirección del rayo que atraviesa el campo escalar se puede recorrer cada uno de los puntos de ese campo para calcular su contribución al color de la superficie del cubo. Este proceso se realiza en el Pixel Shader que representará el resultado final en pantalla.     1 float4 RenderVolumePixelShaderFunction(VertexShaderOutput input) : COLOR0     2 {     3     //Calculamos que puntos de las texturas debemos muestrear     4     float2 texC = input.InterpolatedTransformedPosition.xy /= input.InterpolatedTransformedPosition.w;     5     //lo llevamos al rango [0,1] espacio de coordenadas de textura desde espacio de proyeccion 2D     6     texC.x =  0.5f*texC.x + 0.5f;     7     texC.y = -0.5f*texC.y + 0.5f;     8     //Muestreamos las texturas de posiciones iniciales y finales     9     float3 frontPos = tex2D(FrontTextureSampler, texC);    10     float3 backPos = tex2D(BackTextureSampler, texC);    11     //Calculamos el punto inicial y la direccion    12     float4 currentPosition = float4(frontPos,0);    13     float3 direction = normalize(backPos - frontPos);    14     //Inicializamos las variables del color    15     float4 color = float4(0, 0, 0, 0);    16     float4 src = 0;    17     float value = 0;    18     //Recorremos el campo escalar en la dirección calculada    19     //acumulando opacidad en función del campo    20     float3 Step = direction * (1.0f/256.0f);    21     for(int i = 0; i &lt; 256; i++)    22     {    23         //muestreamos la textura           24         value = tex3Dlod(VolumeTextureSampler, currentPosition).r;    25         src = (float4)value;    26         //Front to back blending    27         src.rgb *= src.a;    28         color = (1.0f - color.a)*src + color;    29         //advance the current position    30         currentPosition.xyz += Step;    31     }    32     return color;    33 } El rendimiento de esta técnica al ser completamente acelerada por GPU es muy bueno como se puede constatar en los siguientes videos obtenidos con una tarjeta gráfica de gama media/baja con un consumo de CPU mínimo. Basado en un artículo original de Graphic Runner. Campos escalares obtenidos de vorbis. Bibliografía: GPU - Based Interactive Visualization Techniques - D. Weiskopf" />
<meta property="og:description" content="La representación volumétrica es una técnica que permite la representación de campos escalares tridimensionales. Sus aplicaciones son múltiples: representación de imágenes del cuerpo humano procedentes de diversos instrumentos sensores con fines médicos, representación realista de nubes u otros fenómenos gaseosos en simulaciones visuales en entornos virtuales, o representación de diversas estructuras y constructos en la ciencia y la ingeniería. En este artículo se describirá una variante de la técnica basada en texturas conocida como ‘volume ray casting’. Conceptualmente dicha técnica consiste en el lanzamiento de rayos con origen en la cámara de tal forma que atraviesen el volumen que contiene el campo escalar. El color resultante que se ‘pintará’ en la superficie del volumen en el punto de entrada de cada rayo será una función de los puntos que el rayo atravesó al pasar por el volumen. Para su implementación se utilizará la plataforma XNA y se hará uso de la aceleración grafica que nos proporcionan la GPU. Será necesaria una tarjeta que soporte al menos la versión 3.0 del modelo de sombreadores (Shader Model 3.0). El proceso comienza con la representación de un volumen que actuará como frontera del campo escalar, es decir, el campo escalar se encontrará completamente en el interior de ese volumen. Utilizaremos un cubo. En primer lugar representaremos las posiciones de entrada del rayo y de salida en dos texturas que posteriormente utilizaremos para determinar la dirección. Al Vertex Shader en la GPU se le harán llegar las posiciones sin transformar de los vértices del cubo. Dichas coordenadas se copiaran a la variable InterpolatedPosition a la salida del Vertex Shader. Dicha variable está marcada como coordenadas de textura por lo que a la entrada del pixel shader se recibiran las coordenadas interpoladas. Lo mismo se hará para la variable InterpolatedTransformedPosition solo que en este caso almacenaremos las coordenadas transformadas por la combinación de las matrices de posicionamiento en el mundo (world), vista (view) y proyección (projection) que serán suministradas a la entrada del programa de la GPU como parámetros. Esta última variable será utilizada posteriormente para localizar la posición exacta donde se deben muestrear las texturas para obtener la dirección del rayo.     1 struct VertexShaderInput     2 {     3     float4 Position : POSITION0;     4 };     5     6 struct VertexShaderOutput     7 {     8     float4 Position : POSITION0;     9     float4 InterpolatedPosition : TEXCOORD0;    10     float4 InterpolatedTransformedPosition : TEXCOORD1;    11 };    12    13 VertexShaderOutput VertexShaderFunction(VertexShaderInput input)    14 {    15     VertexShaderOutput output;    16    17     float4 worldPosition = mul(input.Position, World);    18     float4 viewPosition = mul(worldPosition, View);    19     output.Position = mul(viewPosition, Projection);    20     output.InterpolatedPosition = input.Position;    21     output.InterpolatedTransformedPosition = output.Position;    22     return output;    23 }    24    25 float4 RenderPositionsPixelShaderFunction(VertexShaderOutput input) : COLOR0    26 {    27     float4 color = input.InterpolatedPosition;    28     return color;    29 } Se representarán las caras frontales del cubo en una textura utilizando el estado de representación CullMode.CounterClockWise. El color asignado a la textura en realidad contiene las coordenadas tridimensionades del cubo en el espacio de coordenadas local del modelo en el formato (x,y,z,1). A continuación se repite la operación pero esta vez representando las caras interiores del cubo. El siguiente y ultimo paso es la representación del cubo, solo que en esta ocasión el color resultante será función del campo escalar, muestreado en base a las direcciones grabadas en las texturas anteriores. Al muestrear cada una de las texturas anteriores podemos obtener para cada punto (x,y) de la textura, las coordenadas (x,y,z) del cubo por las cuales entró el rayo y por las cuales salió. Con estas dos coordenadas se puede calcular la dirección del rayo y al conocer el punto inicial y la dirección del rayo que atraviesa el campo escalar se puede recorrer cada uno de los puntos de ese campo para calcular su contribución al color de la superficie del cubo. Este proceso se realiza en el Pixel Shader que representará el resultado final en pantalla.     1 float4 RenderVolumePixelShaderFunction(VertexShaderOutput input) : COLOR0     2 {     3     //Calculamos que puntos de las texturas debemos muestrear     4     float2 texC = input.InterpolatedTransformedPosition.xy /= input.InterpolatedTransformedPosition.w;     5     //lo llevamos al rango [0,1] espacio de coordenadas de textura desde espacio de proyeccion 2D     6     texC.x =  0.5f*texC.x + 0.5f;     7     texC.y = -0.5f*texC.y + 0.5f;     8     //Muestreamos las texturas de posiciones iniciales y finales     9     float3 frontPos = tex2D(FrontTextureSampler, texC);    10     float3 backPos = tex2D(BackTextureSampler, texC);    11     //Calculamos el punto inicial y la direccion    12     float4 currentPosition = float4(frontPos,0);    13     float3 direction = normalize(backPos - frontPos);    14     //Inicializamos las variables del color    15     float4 color = float4(0, 0, 0, 0);    16     float4 src = 0;    17     float value = 0;    18     //Recorremos el campo escalar en la dirección calculada    19     //acumulando opacidad en función del campo    20     float3 Step = direction * (1.0f/256.0f);    21     for(int i = 0; i &lt; 256; i++)    22     {    23         //muestreamos la textura           24         value = tex3Dlod(VolumeTextureSampler, currentPosition).r;    25         src = (float4)value;    26         //Front to back blending    27         src.rgb *= src.a;    28         color = (1.0f - color.a)*src + color;    29         //advance the current position    30         currentPosition.xyz += Step;    31     }    32     return color;    33 } El rendimiento de esta técnica al ser completamente acelerada por GPU es muy bueno como se puede constatar en los siguientes videos obtenidos con una tarjeta gráfica de gama media/baja con un consumo de CPU mínimo. Basado en un artículo original de Graphic Runner. Campos escalares obtenidos de vorbis. Bibliografía: GPU - Based Interactive Visualization Techniques - D. Weiskopf" />
<link rel="canonical" href="http://localhost:4000/2009/03/10/representacion-campos-escalares-tridimensionales.html" />
<meta property="og:url" content="http://localhost:4000/2009/03/10/representacion-campos-escalares-tridimensionales.html" />
<meta property="og:site_name" content="la ciudadela" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-03-10T00:00:00+01:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2009/03/10/representacion-campos-escalares-tridimensionales.html"},"author":{"@type":"Person","name":"peancor"},"@type":"BlogPosting","url":"http://localhost:4000/2009/03/10/representacion-campos-escalares-tridimensionales.html","headline":"Representación de campos escalares tridimensionales","dateModified":"2009-03-10T00:00:00+01:00","datePublished":"2009-03-10T00:00:00+01:00","description":"La representación volumétrica es una técnica que permite la representación de campos escalares tridimensionales. Sus aplicaciones son múltiples: representación de imágenes del cuerpo humano procedentes de diversos instrumentos sensores con fines médicos, representación realista de nubes u otros fenómenos gaseosos en simulaciones visuales en entornos virtuales, o representación de diversas estructuras y constructos en la ciencia y la ingeniería. En este artículo se describirá una variante de la técnica basada en texturas conocida como ‘volume ray casting’. Conceptualmente dicha técnica consiste en el lanzamiento de rayos con origen en la cámara de tal forma que atraviesen el volumen que contiene el campo escalar. El color resultante que se ‘pintará’ en la superficie del volumen en el punto de entrada de cada rayo será una función de los puntos que el rayo atravesó al pasar por el volumen. Para su implementación se utilizará la plataforma XNA y se hará uso de la aceleración grafica que nos proporcionan la GPU. Será necesaria una tarjeta que soporte al menos la versión 3.0 del modelo de sombreadores (Shader Model 3.0). El proceso comienza con la representación de un volumen que actuará como frontera del campo escalar, es decir, el campo escalar se encontrará completamente en el interior de ese volumen. Utilizaremos un cubo. En primer lugar representaremos las posiciones de entrada del rayo y de salida en dos texturas que posteriormente utilizaremos para determinar la dirección. Al Vertex Shader en la GPU se le harán llegar las posiciones sin transformar de los vértices del cubo. Dichas coordenadas se copiaran a la variable InterpolatedPosition a la salida del Vertex Shader. Dicha variable está marcada como coordenadas de textura por lo que a la entrada del pixel shader se recibiran las coordenadas interpoladas. Lo mismo se hará para la variable InterpolatedTransformedPosition solo que en este caso almacenaremos las coordenadas transformadas por la combinación de las matrices de posicionamiento en el mundo (world), vista (view) y proyección (projection) que serán suministradas a la entrada del programa de la GPU como parámetros. Esta última variable será utilizada posteriormente para localizar la posición exacta donde se deben muestrear las texturas para obtener la dirección del rayo.     1 struct VertexShaderInput     2 {     3     float4 Position : POSITION0;     4 };     5     6 struct VertexShaderOutput     7 {     8     float4 Position : POSITION0;     9     float4 InterpolatedPosition : TEXCOORD0;    10     float4 InterpolatedTransformedPosition : TEXCOORD1;    11 };    12    13 VertexShaderOutput VertexShaderFunction(VertexShaderInput input)    14 {    15     VertexShaderOutput output;    16    17     float4 worldPosition = mul(input.Position, World);    18     float4 viewPosition = mul(worldPosition, View);    19     output.Position = mul(viewPosition, Projection);    20     output.InterpolatedPosition = input.Position;    21     output.InterpolatedTransformedPosition = output.Position;    22     return output;    23 }    24    25 float4 RenderPositionsPixelShaderFunction(VertexShaderOutput input) : COLOR0    26 {    27     float4 color = input.InterpolatedPosition;    28     return color;    29 } Se representarán las caras frontales del cubo en una textura utilizando el estado de representación CullMode.CounterClockWise. El color asignado a la textura en realidad contiene las coordenadas tridimensionades del cubo en el espacio de coordenadas local del modelo en el formato (x,y,z,1). A continuación se repite la operación pero esta vez representando las caras interiores del cubo. El siguiente y ultimo paso es la representación del cubo, solo que en esta ocasión el color resultante será función del campo escalar, muestreado en base a las direcciones grabadas en las texturas anteriores. Al muestrear cada una de las texturas anteriores podemos obtener para cada punto (x,y) de la textura, las coordenadas (x,y,z) del cubo por las cuales entró el rayo y por las cuales salió. Con estas dos coordenadas se puede calcular la dirección del rayo y al conocer el punto inicial y la dirección del rayo que atraviesa el campo escalar se puede recorrer cada uno de los puntos de ese campo para calcular su contribución al color de la superficie del cubo. Este proceso se realiza en el Pixel Shader que representará el resultado final en pantalla.     1 float4 RenderVolumePixelShaderFunction(VertexShaderOutput input) : COLOR0     2 {     3     //Calculamos que puntos de las texturas debemos muestrear     4     float2 texC = input.InterpolatedTransformedPosition.xy /= input.InterpolatedTransformedPosition.w;     5     //lo llevamos al rango [0,1] espacio de coordenadas de textura desde espacio de proyeccion 2D     6     texC.x =  0.5f*texC.x + 0.5f;     7     texC.y = -0.5f*texC.y + 0.5f;     8     //Muestreamos las texturas de posiciones iniciales y finales     9     float3 frontPos = tex2D(FrontTextureSampler, texC);    10     float3 backPos = tex2D(BackTextureSampler, texC);    11     //Calculamos el punto inicial y la direccion    12     float4 currentPosition = float4(frontPos,0);    13     float3 direction = normalize(backPos - frontPos);    14     //Inicializamos las variables del color    15     float4 color = float4(0, 0, 0, 0);    16     float4 src = 0;    17     float value = 0;    18     //Recorremos el campo escalar en la dirección calculada    19     //acumulando opacidad en función del campo    20     float3 Step = direction * (1.0f/256.0f);    21     for(int i = 0; i &lt; 256; i++)    22     {    23         //muestreamos la textura           24         value = tex3Dlod(VolumeTextureSampler, currentPosition).r;    25         src = (float4)value;    26         //Front to back blending    27         src.rgb *= src.a;    28         color = (1.0f - color.a)*src + color;    29         //advance the current position    30         currentPosition.xyz += Step;    31     }    32     return color;    33 } El rendimiento de esta técnica al ser completamente acelerada por GPU es muy bueno como se puede constatar en los siguientes videos obtenidos con una tarjeta gráfica de gama media/baja con un consumo de CPU mínimo. Basado en un artículo original de Graphic Runner. Campos escalares obtenidos de vorbis. Bibliografía: GPU - Based Interactive Visualization Techniques - D. Weiskopf","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="la ciudadela" /><script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">la ciudadela</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Representación de campos escalares tridimensionales</h1>
  </header>

  <div class="post-content">
    <p>La representación volumétrica es una técnica que permite la representación de campos escalares tridimensionales. Sus aplicaciones son múltiples: representación de imágenes del cuerpo humano procedentes de diversos instrumentos sensores con fines médicos, representación realista de nubes u otros fenómenos gaseosos en simulaciones visuales en entornos virtuales, o representación de diversas estructuras y constructos en la ciencia y la ingeniería.</p>

<p>En este artículo se describirá una variante de la técnica basada en texturas conocida como ‘volume ray casting’. Conceptualmente dicha técnica consiste en el lanzamiento de rayos con origen en la cámara de tal forma que atraviesen el volumen que contiene el campo escalar. El color resultante que se ‘pintará’ en la superficie del volumen en el punto de entrada de cada rayo será una función de los puntos que el rayo atravesó al pasar por el volumen.</p>

<p>Para su implementación se utilizará la plataforma XNA y se hará uso de la aceleración grafica que nos proporcionan la GPU. Será necesaria una tarjeta que soporte al menos la versión 3.0 del modelo de sombreadores (<em>Shader Model 3.0</em>).</p>

<p>El proceso comienza con la representación de un volumen que actuará como frontera del campo escalar, es decir, el campo escalar se encontrará completamente en el interior de ese volumen. Utilizaremos un cubo.</p>

<p>En primer lugar representaremos las posiciones de entrada del rayo y de salida en dos texturas que posteriormente utilizaremos para determinar la dirección. Al <em>Vertex Shader</em> en la GPU se le harán llegar las posiciones sin transformar de los vértices del cubo. Dichas coordenadas se copiaran a la variable <em>InterpolatedPosition</em> a la salida del <em>Vertex Shader</em>. Dicha variable está marcada como coordenadas de textura por lo que a la entrada del pixel shader se recibiran las coordenadas interpoladas. Lo mismo se hará para la variable <em>InterpolatedTransformedPosition</em> solo que en este caso almacenaremos las coordenadas transformadas por la combinación de las matrices de posicionamiento en el mundo (world), vista (view) y proyección (projection) que serán suministradas a la entrada del programa de la GPU como parámetros. Esta última variable será utilizada posteriormente para localizar la posición exacta donde se deben muestrear las texturas para obtener la dirección del rayo.</p>
<div style="font-size: 8pt; background: white; color: black; font-family: consolas;">
<p style="margin: 0px;"><span style="color: #2b91af;">    1</span> <span style="color: blue;">struct</span> VertexShaderInput</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    2</span> {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    3</span>     <span style="color: blue;">float4</span> Position : <span style="color: navy;">POSITION0</span>;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    4</span> };</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    5</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">    6</span> <span style="color: blue;">struct</span> VertexShaderOutput</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    7</span> {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    8</span>     <span style="color: blue;">float4</span> Position : <span style="color: navy;">POSITION0</span>;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    9</span>     <span style="color: blue;">float4</span> InterpolatedPosition : <span style="color: navy;">TEXCOORD0</span>;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   10</span>     <span style="color: blue;">float4</span> InterpolatedTransformedPosition : <span style="color: navy;">TEXCOORD1</span>;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   11</span> };</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   12</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   13</span> VertexShaderOutput VertexShaderFunction(VertexShaderInput input)</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   14</span> {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   15</span>     VertexShaderOutput output;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   16</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   17</span>     <span style="color: blue;">float4</span> worldPosition = <span style="color: blue;">mul</span>(input.Position, World);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   18</span>     <span style="color: blue;">float4</span> viewPosition = <span style="color: blue;">mul</span>(worldPosition, View);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   19</span>     output.Position = <span style="color: blue;">mul</span>(viewPosition, Projection);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   20</span>     output.InterpolatedPosition = input.Position;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   21</span>     output.InterpolatedTransformedPosition = output.Position;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   22</span>     <span style="color: blue;">return</span> output;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   23</span> }</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   24</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   25</span> <span style="color: blue;">float4</span> RenderPositionsPixelShaderFunction(VertexShaderOutput input) : <span style="color: navy;">COLOR0</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   26</span> {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   27</span>     <span style="color: blue;">float4</span> color = input.InterpolatedPosition;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   28</span>     <span style="color: blue;">return</span> color;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   29</span> }</p>

</div>
<p>Se representarán las caras frontales del cubo en una textura utilizando el estado de representación <em>CullMode.CounterClockWise</em>. El color asignado a la textura en realidad contiene las coordenadas tridimensionades del cubo en el espacio de coordenadas local del modelo en el formato (x,y,z,1).</p>

<p><img src="/images/07-11/2009-03-volume-rendering-front-texture.jpg" alt="" /></p>

<p>A continuación se repite la operación pero esta vez representando las caras interiores del cubo.</p>

<p><img src="/images/07-11/2009-03-volume-rendering-back-texture.jpg" alt="" /></p>

<p>El siguiente y ultimo paso es la representación del cubo, solo que en esta ocasión el color resultante será función del campo escalar, muestreado en base a las direcciones grabadas en las texturas anteriores. Al muestrear cada una de las texturas anteriores podemos obtener para cada punto (x,y) de la textura, las coordenadas (x,y,z) del cubo por las cuales entró el rayo y por las cuales salió. Con estas dos coordenadas se puede calcular la dirección del rayo y al conocer el punto inicial y la dirección del rayo que atraviesa el campo escalar se puede recorrer cada uno de los puntos de ese campo para calcular su contribución al color de la superficie del cubo. Este proceso se realiza en el <em>Pixel Shader</em> que representará el resultado final en pantalla.</p>

<p><img src="/images/07-11/2009-03-volume-rendering-skull.jpg" alt="" /></p>
<div style="font-size: 8pt; background: white; color: black; font-family: consolas;">
<p style="margin: 0px;"><span style="color: #2b91af;">    1</span> <span style="color: blue;">float4</span> RenderVolumePixelShaderFunction(VertexShaderOutput input) : <span style="color: navy;">COLOR0</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">    2</span> {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    3</span>     <span style="color: green;">//Calculamos que puntos de las texturas debemos muestrear</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">    4</span>     <span style="color: blue;">float2</span> texC = input.InterpolatedTransformedPosition.xy /= input.InterpolatedTransformedPosition.w;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    5</span>     <span style="color: green;">//lo llevamos al rango [0,1] espacio de coordenadas de textura desde espacio de proyeccion 2D</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">    6</span>     texC.x =  0.5f*texC.x + 0.5f;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    7</span>     texC.y = -0.5f*texC.y + 0.5f;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">    8</span>     <span style="color: green;">//Muestreamos las texturas de posiciones iniciales y finales</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">    9</span>     <span style="color: blue;">float3</span> frontPos = <span style="color: blue;">tex2D</span>(FrontTextureSampler, texC);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   10</span>     <span style="color: blue;">float3</span> backPos = <span style="color: blue;">tex2D</span>(BackTextureSampler, texC);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   11</span>     <span style="color: green;">//Calculamos el punto inicial y la direccion</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   12</span>     <span style="color: blue;">float4</span> currentPosition = <span style="color: blue;">float4</span>(frontPos,0);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   13</span>     <span style="color: blue;">float3</span> direction = <span style="color: blue;">normalize</span>(backPos - frontPos);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   14</span>     <span style="color: green;">//Inicializamos las variables del color</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   15</span>     <span style="color: blue;">float4</span> color = <span style="color: blue;">float4</span>(0, 0, 0, 0);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   16</span>     <span style="color: blue;">float4</span> src = 0;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   17</span>     <span style="color: blue;">float</span> value = 0;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   18</span>     <span style="color: green;">//Recorremos el campo escalar en la dirección calculada</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   19</span>     <span style="color: green;">//acumulando opacidad en función del campo</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   20</span>     <span style="color: blue;">float3</span> Step = direction * (1.0f/256.0f);</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   21</span>     <span style="color: blue;">for</span>(<span style="color: blue;">int</span> i = 0; i &lt; 256; i++)</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   22</span>     {</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   23</span>         <span style="color: green;">//muestreamos la textura        </span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   24</span>         value = <span style="color: blue;">tex3Dlod</span>(VolumeTextureSampler, currentPosition).r;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   25</span>         src = (<span style="color: blue;">float4</span>)value;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   26</span>         <span style="color: green;">//Front to back blending</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   27</span>         src.rgb *= src.a;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   28</span>         color = (1.0f - color.a)*src + color;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   29</span>         <span style="color: green;">//advance the current position</span></p>
<p style="margin: 0px;"><span style="color: #2b91af;">   30</span>         currentPosition.xyz += Step;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   31</span>     }</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   32</span>     <span style="color: blue;">return</span> color;</p>
<p style="margin: 0px;"><span style="color: #2b91af;">   33</span> }</p>

</div>
<p>El rendimiento de esta técnica al ser completamente acelerada por GPU es muy bueno como se puede constatar en los siguientes videos obtenidos con una tarjeta gráfica de gama media/baja con un consumo de CPU mínimo.</p>

<div class="flex-video">
  <iframe id="ytplayer" type="text/html" width="640" height="360" src="https://youtube.com/embed/aRkn8erVXa4" frameborder="0"></iframe>
</div>

<div class="flex-video">
  <iframe id="ytplayer" type="text/html" width="640" height="360" src="https://youtube.com/embed/_O-2TevZqpM" frameborder="0"></iframe>
</div>

<h4></h4>
<h6>Basado en un artículo original de <a href="http://graphicsrunner.blogspot.com/2009/01/volume-rendering-101.html" target="_blank">Graphic Runner</a>.</h6>
<h6>Campos escalares obtenidos de <a href="http://www.gris.uni-tuebingen.de/edu/areas/scivis/volren/datasets/datasets.html" target="_blank">vorbis</a>.</h6>
<h6>Bibliografía: GPU - Based Interactive Visualization Techniques - D. Weiskopf</h6>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">la ciudadela</h2>
        <ul class="contact-list">
          <li class="p-name">peancor</li></ul>
      </div>

      <div class="footer-col one-half">
        <p>Blog personal de Pedro Anuarbe Cortes (@peancor)
</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://twitter.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
