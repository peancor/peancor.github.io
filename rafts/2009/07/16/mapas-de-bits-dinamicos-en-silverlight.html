<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Mapas de bits dinámicos en Silverlight | la ciudadela</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Mapas de bits dinámicos en Silverlight" />
<meta name="author" content="peancor" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Una de las novedades introducidas en la versión 3 de Silverlight es la clase WriteableBitmap que nos permite la generación dinámica de mapas de bits o bitmaps. Su funcionamiento es muy sencillo, basta con pasar en el constructor el número de pixels de ancho y de alto que queremos que tenga la imagen para generarla y una vez generada podemos acceder a su contenido a través de la propiedad Pixels. En el siguiente fragmento de código se construye un bitmap de 320x200 pixels y se establece el pixel en la posición (x, y) al color (r,g,b). Una vez modificado el bitmap se debe llamar a la función Invalidate para actualizar su contenido. 1: var bitmap = new WriteableBitmap(320,200); 2: var pixelColor = BitConverter.ToInt32(new byte[] { (byte)b, (byte)g, (byte)r, 255 }, 0) 3: bitmap.Pixels[x + y * bitmap.PixelWidth] = pixelColor; 4: bitmap.Invalidate(); Por supuesto es necesario asignar el bitmap a la propiedad Source de un control Image para representarle en pantalla. Una funcionalidad interesante añadida es el método Render que permite representar en el bitmap un control gráfico descendiente de UIElement después de aplicarle una transformación (rotación,escala,posición) lo que abre la puerta a la generación de interesantes efectos. La siguiente ilustración muestra la generación dinámica de bitmaps. Si posa el cursor sobre la imagen podrá ver una representación de metaballs construida sobre un WriteableBitmap." />
<meta property="og:description" content="Una de las novedades introducidas en la versión 3 de Silverlight es la clase WriteableBitmap que nos permite la generación dinámica de mapas de bits o bitmaps. Su funcionamiento es muy sencillo, basta con pasar en el constructor el número de pixels de ancho y de alto que queremos que tenga la imagen para generarla y una vez generada podemos acceder a su contenido a través de la propiedad Pixels. En el siguiente fragmento de código se construye un bitmap de 320x200 pixels y se establece el pixel en la posición (x, y) al color (r,g,b). Una vez modificado el bitmap se debe llamar a la función Invalidate para actualizar su contenido. 1: var bitmap = new WriteableBitmap(320,200); 2: var pixelColor = BitConverter.ToInt32(new byte[] { (byte)b, (byte)g, (byte)r, 255 }, 0) 3: bitmap.Pixels[x + y * bitmap.PixelWidth] = pixelColor; 4: bitmap.Invalidate(); Por supuesto es necesario asignar el bitmap a la propiedad Source de un control Image para representarle en pantalla. Una funcionalidad interesante añadida es el método Render que permite representar en el bitmap un control gráfico descendiente de UIElement después de aplicarle una transformación (rotación,escala,posición) lo que abre la puerta a la generación de interesantes efectos. La siguiente ilustración muestra la generación dinámica de bitmaps. Si posa el cursor sobre la imagen podrá ver una representación de metaballs construida sobre un WriteableBitmap." />
<link rel="canonical" href="http://localhost:4000/2009/07/16/mapas-de-bits-dinamicos-en-silverlight.html" />
<meta property="og:url" content="http://localhost:4000/2009/07/16/mapas-de-bits-dinamicos-en-silverlight.html" />
<meta property="og:site_name" content="la ciudadela" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-07-16T00:00:00+02:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2009/07/16/mapas-de-bits-dinamicos-en-silverlight.html"},"author":{"@type":"Person","name":"peancor"},"@type":"BlogPosting","url":"http://localhost:4000/2009/07/16/mapas-de-bits-dinamicos-en-silverlight.html","headline":"Mapas de bits dinámicos en Silverlight","dateModified":"2009-07-16T00:00:00+02:00","datePublished":"2009-07-16T00:00:00+02:00","description":"Una de las novedades introducidas en la versión 3 de Silverlight es la clase WriteableBitmap que nos permite la generación dinámica de mapas de bits o bitmaps. Su funcionamiento es muy sencillo, basta con pasar en el constructor el número de pixels de ancho y de alto que queremos que tenga la imagen para generarla y una vez generada podemos acceder a su contenido a través de la propiedad Pixels. En el siguiente fragmento de código se construye un bitmap de 320x200 pixels y se establece el pixel en la posición (x, y) al color (r,g,b). Una vez modificado el bitmap se debe llamar a la función Invalidate para actualizar su contenido. 1: var bitmap = new WriteableBitmap(320,200); 2: var pixelColor = BitConverter.ToInt32(new byte[] { (byte)b, (byte)g, (byte)r, 255 }, 0) 3: bitmap.Pixels[x + y * bitmap.PixelWidth] = pixelColor; 4: bitmap.Invalidate(); Por supuesto es necesario asignar el bitmap a la propiedad Source de un control Image para representarle en pantalla. Una funcionalidad interesante añadida es el método Render que permite representar en el bitmap un control gráfico descendiente de UIElement después de aplicarle una transformación (rotación,escala,posición) lo que abre la puerta a la generación de interesantes efectos. La siguiente ilustración muestra la generación dinámica de bitmaps. Si posa el cursor sobre la imagen podrá ver una representación de metaballs construida sobre un WriteableBitmap.","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="la ciudadela" /><script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">la ciudadela</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Mapas de bits dinámicos en Silverlight</h1>
  </header>

  <div class="post-content">
    <p>Una de las novedades introducidas en la versión 3 de Silverlight es la clase <em>WriteableBitmap</em> que nos permite la generación dinámica de mapas de bits o bitmaps.</p>

<p>Su funcionamiento es muy sencillo, basta con pasar en el constructor el número de pixels de ancho y de alto que queremos que tenga la imagen para generarla y una vez generada podemos acceder a su contenido a través de la propiedad <em>Pixels</em>.</p>

<p>En el siguiente fragmento de código se construye un bitmap de 320x200 pixels y se establece el pixel en la posición (x, y) al color (r,g,b). Una vez modificado el bitmap se debe llamar a la función <em>Invalidate</em> para actualizar su contenido.</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre style="text-align: left; line-height: 12pt; background-color: white; margin: 0em; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;"><span id="lnum1" style="color: #606060;"> 1:</span> var bitmap = <span style="color: #0000ff;">new</span> WriteableBitmap(320,200);</pre>
<pre style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 0em; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;"><span id="lnum2" style="color: #606060;"> 2:</span> var pixelColor = BitConverter.ToInt32(<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[] { (<span style="color: #0000ff;">byte</span>)b, (<span style="color: #0000ff;">byte</span>)g, (<span style="color: #0000ff;">byte</span>)r, 255 }, 0)</pre>
<pre style="text-align: left; line-height: 12pt; background-color: white; margin: 0em; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;"><span id="lnum3" style="color: #606060;"> 3:</span> bitmap.Pixels[x + y * bitmap.PixelWidth] = pixelColor;</pre>
<pre style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 0em; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;"><span id="lnum4" style="color: #606060;"> 4:</span> bitmap.Invalidate();</pre>
</div>
</div>
<p>Por supuesto es necesario asignar el bitmap a la propiedad <em>Source</em> de un control <em>Image</em> para representarle en pantalla.</p>

<p>Una funcionalidad interesante añadida es el método <em>Render</em> que permite representar en el bitmap un control gráfico descendiente de <em>UIElement</em> después de aplicarle una transformación (rotación,escala,posición) lo que abre la puerta a la generación de interesantes efectos.</p>

<p>La siguiente ilustración muestra la generación dinámica de <em>bitmaps. Si posa el cursor sobre la imagen podrá ver una representación de </em><a href="http://es.wikipedia.org/wiki/Metaball" target="_blank"><em>metaballs</em></a><em> construida sobre un WriteableBitmap.</em></p>

<object width="500" height="300" data="data:application/x-silverlight-2," type="application/x-silverlight-2">
    <param name="source" value="/files/2009-07-metaballs.xap" />
</object>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">la ciudadela</h2>
        <ul class="contact-list">
          <li class="p-name">peancor</li></ul>
      </div>

      <div class="footer-col one-half">
        <p>Blog personal de Pedro Anuarbe Cortes (@peancor)
</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://twitter.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
