<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Introducción al contenedor Unity | la ciudadela</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Introducción al contenedor Unity" />
<meta name="author" content="peancor" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Unity es un contenedor de inyecci&oacute;n de dependencias que facilita el desarrollo de aplicaciones proporcionando un sistema para gestionar tanto la construcci&oacute;n de objetos como las dependencias entre los diferentes componentes de una aplicaci&oacute;n. Supongamos que hemos definido&nbsp; un interface a trav&eacute;s del cual gestionaremos todo el sistema de registro de eventos de nuestra aplicaci&oacute;n. &nbsp;&nbsp;&nbsp; public interface ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; void Log(string message); &nbsp;&nbsp;&nbsp; } &nbsp;Y a su vez una clase que implementa dicho interface y que en este caso simplemente enviara el mensaje a la consola del sistema. &nbsp;&nbsp;&nbsp; public class ConsoleLoggingService: ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public void Log(string message) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Console: &quot; + message); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;El funcionamiento b&aacute;sico del contenedor es sencillo, en primer lugar registraremos en el contenedor los tipos de objetos que deseamos que gestione. Al hacerlo, adem&aacute;s, indicaremos al contenedor cual debe ser el ciclo de vida del objetos de ese tipo. En el caso que nos ocupa registraremos el interface ILoggingService en el contenedor mapeando dicho interface al tipo ConsoleLoggingService de tal forma que cuando solicitemos al contenedor un objeto implementando el interface ILoggingService nos devuelva un objeto del tipo ConsoleLoggingService. Como adem&aacute;s deseamos que en la aplicaci&oacute;n solo exista una &uacute;nica instancia del sistema de eventos (Singleton), indicaremos al contenedor que se encargue de controlar la vida del objeto, de esta forma la primera vez que solicitemos el interface se crear&aacute; el objeto pero las veces sucesivas se nos devolvera una referencia al mismo objeto. El siguiente fragmento de c&oacute;digo muestra el proceso de registro utilizando uno de los m&eacute;todos que nos brinda el contenedor. &nbsp;&nbsp;&nbsp; IUnityContainer container = new UnityContainer(); &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); Veamos como funciona la inyecci&oacute;n de dependencias. El contenedor nos proporciona varias formas de realizar la inyecci&oacute;n de dependencias: a trav&eacute;s del constructor, a trav&eacute;s de una propiedad &oacute; a trav&eacute;s de un m&eacute;todo. En el caso general, las inyecci&oacute;n requiere que marquemos el constructor, la propiedad o el m&eacute;todo con un atributo que indicar&aacute; al contenedor que debe realizar la inyecci&oacute;n de un objeto. El siguiente fragmento de c&oacute;digo muestra la utilizaci&oacute;n del atributo InjectionConstructor para indicar al contenedor que debe inyectar un objeto con el interface ILoggingService a la hora de construir un objeto del tipo MainApplicationModule. &nbsp;&nbsp;&nbsp; public class MainApplicationModule &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ILoggingService mLoggingService; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [InjectionConstructor] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public MainApplicationModule(ILoggingService loggingService) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService = loggingService; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService.Log(&quot;Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n&quot;); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;N&oacute;tese que en este caso, al existir solo un constructor, el contenedor inyectar&aacute; las dependencias en el constructor de forma aut&oacute;matica aunque no hayamos marcado el constructor, sin embargo, dicho atributo es &uacute;til para indicar que constructor utilizar en el caso de que existan varios. Si tenemos una clase con varios constructores y ninguno de ellos est&aacute; marcado con el atributo de inyecci&oacute;n, el contenedor utilizar&aacute; aquel que tenga m&aacute;s par&aacute;metros, lanzando una excepci&oacute;n en el caso de que exista m&aacute;s de un constructor que cumpla la propiedad de tener el m&aacute;ximo n&uacute;mero de par&aacute;metros. &nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) &nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; using (IUnityContainer container = new UnityContainer()) &nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); &nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MainApplicationModule mainModule = container.Resolve&lt;MainApplicationModule&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.ReadLine(); &nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;En la linea 7 del anterior fragmento de c&oacute;digo, solicitamos al contenedor que nos devuelva un objeto del tipo MainApplicationModule. Obs&eacute;rvese que en este caso no ha sido necesario registrar el objeto con el contenedor previamente. La utilidad de crear un objeto a trav&eacute;s del contenedor de un tipo que no ha sido previamente registrado es que el contenedor evaluar&aacute; e inyectar&aacute; las dependencias de dicho objeto al generarle. Despu&eacute;s de la ejecuci&oacute;n de la linea 7 aparecer&aacute; en la consola del sistema la siguiente l&iacute;nea indicando que se ha realizado el proceso de inyecci&oacute;n de la dependencia ILoggingService correctamente: Console: Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n Las ventajas de la utilizacion del patron de dise&ntilde;o de inyecci&oacute;n de dependencias se hacen evidentes a m&eacute;dida que el n&uacute;mero de componentes de la aplicaci&oacute;n aumenta, permitiendonos mantener un acoplamiento d&eacute;bil entre dichos componentes y facilitando el mantenimiento posterior de la aplicaci&oacute;n al unificar el sistema de construcci&oacute;n y cableado de objetos. Puede que surja la pregunta de que tipo de objetos debemos instanciar a trav&eacute;s del contenedor. En mi experiencia, los componentes que forman parte de la arquitectura o flujo principal de la aplicaci&oacute;n, esto es, servicios, vistas, presentadores, m&oacute;delos, etc, son buenos candidatos para ser incluidos en el contenedor. Finalizaremos este art&iacute;culo enumerando dos ventajas instantaneas de utilizar un contenedor para estructurar nuestra aplicaci&oacute;n: Si en lugar de mostrar los eventos del sistema por la consola decidimos registrarles en una base de datos, podr&iacute;amos definir un nuevo tipo DatabaseLoggingService implementando el interface ILoggingService y registrar dicho tipo en lugar de ConsoleLoggingService. Con esa sencilla modificaci&oacute;n la aplicaci&oacute;n pasar&iacute;a a registrar los eventos en una base de datos.El contenedor introduce el concepto de &#39;cadena de montaje&#39; y nos permite extender las acciones a realizar a la hora de crear un objeto. Un uso t&iacute;pico es el &#39;EventBroker&#39; o sistema de gesti&oacute;n de eventos que permite marcar eventos de los tipos con el atributo de publicaci&oacute;n y m&eacute;todos con el atributo de suscripci&oacute;n, encargandose el contenedor a la hora de construir los objetos de cablear los publicadores con los suscriptores facilitando la implementaci&oacute;n del patron de dise&ntilde;o observador. &nbsp;" />
<meta property="og:description" content="Unity es un contenedor de inyecci&oacute;n de dependencias que facilita el desarrollo de aplicaciones proporcionando un sistema para gestionar tanto la construcci&oacute;n de objetos como las dependencias entre los diferentes componentes de una aplicaci&oacute;n. Supongamos que hemos definido&nbsp; un interface a trav&eacute;s del cual gestionaremos todo el sistema de registro de eventos de nuestra aplicaci&oacute;n. &nbsp;&nbsp;&nbsp; public interface ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; void Log(string message); &nbsp;&nbsp;&nbsp; } &nbsp;Y a su vez una clase que implementa dicho interface y que en este caso simplemente enviara el mensaje a la consola del sistema. &nbsp;&nbsp;&nbsp; public class ConsoleLoggingService: ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public void Log(string message) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Console: &quot; + message); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;El funcionamiento b&aacute;sico del contenedor es sencillo, en primer lugar registraremos en el contenedor los tipos de objetos que deseamos que gestione. Al hacerlo, adem&aacute;s, indicaremos al contenedor cual debe ser el ciclo de vida del objetos de ese tipo. En el caso que nos ocupa registraremos el interface ILoggingService en el contenedor mapeando dicho interface al tipo ConsoleLoggingService de tal forma que cuando solicitemos al contenedor un objeto implementando el interface ILoggingService nos devuelva un objeto del tipo ConsoleLoggingService. Como adem&aacute;s deseamos que en la aplicaci&oacute;n solo exista una &uacute;nica instancia del sistema de eventos (Singleton), indicaremos al contenedor que se encargue de controlar la vida del objeto, de esta forma la primera vez que solicitemos el interface se crear&aacute; el objeto pero las veces sucesivas se nos devolvera una referencia al mismo objeto. El siguiente fragmento de c&oacute;digo muestra el proceso de registro utilizando uno de los m&eacute;todos que nos brinda el contenedor. &nbsp;&nbsp;&nbsp; IUnityContainer container = new UnityContainer(); &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); Veamos como funciona la inyecci&oacute;n de dependencias. El contenedor nos proporciona varias formas de realizar la inyecci&oacute;n de dependencias: a trav&eacute;s del constructor, a trav&eacute;s de una propiedad &oacute; a trav&eacute;s de un m&eacute;todo. En el caso general, las inyecci&oacute;n requiere que marquemos el constructor, la propiedad o el m&eacute;todo con un atributo que indicar&aacute; al contenedor que debe realizar la inyecci&oacute;n de un objeto. El siguiente fragmento de c&oacute;digo muestra la utilizaci&oacute;n del atributo InjectionConstructor para indicar al contenedor que debe inyectar un objeto con el interface ILoggingService a la hora de construir un objeto del tipo MainApplicationModule. &nbsp;&nbsp;&nbsp; public class MainApplicationModule &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ILoggingService mLoggingService; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [InjectionConstructor] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public MainApplicationModule(ILoggingService loggingService) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService = loggingService; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService.Log(&quot;Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n&quot;); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;N&oacute;tese que en este caso, al existir solo un constructor, el contenedor inyectar&aacute; las dependencias en el constructor de forma aut&oacute;matica aunque no hayamos marcado el constructor, sin embargo, dicho atributo es &uacute;til para indicar que constructor utilizar en el caso de que existan varios. Si tenemos una clase con varios constructores y ninguno de ellos est&aacute; marcado con el atributo de inyecci&oacute;n, el contenedor utilizar&aacute; aquel que tenga m&aacute;s par&aacute;metros, lanzando una excepci&oacute;n en el caso de que exista m&aacute;s de un constructor que cumpla la propiedad de tener el m&aacute;ximo n&uacute;mero de par&aacute;metros. &nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) &nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; using (IUnityContainer container = new UnityContainer()) &nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); &nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MainApplicationModule mainModule = container.Resolve&lt;MainApplicationModule&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.ReadLine(); &nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;En la linea 7 del anterior fragmento de c&oacute;digo, solicitamos al contenedor que nos devuelva un objeto del tipo MainApplicationModule. Obs&eacute;rvese que en este caso no ha sido necesario registrar el objeto con el contenedor previamente. La utilidad de crear un objeto a trav&eacute;s del contenedor de un tipo que no ha sido previamente registrado es que el contenedor evaluar&aacute; e inyectar&aacute; las dependencias de dicho objeto al generarle. Despu&eacute;s de la ejecuci&oacute;n de la linea 7 aparecer&aacute; en la consola del sistema la siguiente l&iacute;nea indicando que se ha realizado el proceso de inyecci&oacute;n de la dependencia ILoggingService correctamente: Console: Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n Las ventajas de la utilizacion del patron de dise&ntilde;o de inyecci&oacute;n de dependencias se hacen evidentes a m&eacute;dida que el n&uacute;mero de componentes de la aplicaci&oacute;n aumenta, permitiendonos mantener un acoplamiento d&eacute;bil entre dichos componentes y facilitando el mantenimiento posterior de la aplicaci&oacute;n al unificar el sistema de construcci&oacute;n y cableado de objetos. Puede que surja la pregunta de que tipo de objetos debemos instanciar a trav&eacute;s del contenedor. En mi experiencia, los componentes que forman parte de la arquitectura o flujo principal de la aplicaci&oacute;n, esto es, servicios, vistas, presentadores, m&oacute;delos, etc, son buenos candidatos para ser incluidos en el contenedor. Finalizaremos este art&iacute;culo enumerando dos ventajas instantaneas de utilizar un contenedor para estructurar nuestra aplicaci&oacute;n: Si en lugar de mostrar los eventos del sistema por la consola decidimos registrarles en una base de datos, podr&iacute;amos definir un nuevo tipo DatabaseLoggingService implementando el interface ILoggingService y registrar dicho tipo en lugar de ConsoleLoggingService. Con esa sencilla modificaci&oacute;n la aplicaci&oacute;n pasar&iacute;a a registrar los eventos en una base de datos.El contenedor introduce el concepto de &#39;cadena de montaje&#39; y nos permite extender las acciones a realizar a la hora de crear un objeto. Un uso t&iacute;pico es el &#39;EventBroker&#39; o sistema de gesti&oacute;n de eventos que permite marcar eventos de los tipos con el atributo de publicaci&oacute;n y m&eacute;todos con el atributo de suscripci&oacute;n, encargandose el contenedor a la hora de construir los objetos de cablear los publicadores con los suscriptores facilitando la implementaci&oacute;n del patron de dise&ntilde;o observador. &nbsp;" />
<link rel="canonical" href="http://localhost:4000/2008/04/13/introduccion-contenedor-unity.html" />
<meta property="og:url" content="http://localhost:4000/2008/04/13/introduccion-contenedor-unity.html" />
<meta property="og:site_name" content="la ciudadela" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2008-04-13T00:00:00+02:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2008/04/13/introduccion-contenedor-unity.html"},"author":{"@type":"Person","name":"peancor"},"@type":"BlogPosting","url":"http://localhost:4000/2008/04/13/introduccion-contenedor-unity.html","headline":"Introducción al contenedor Unity","dateModified":"2008-04-13T00:00:00+02:00","datePublished":"2008-04-13T00:00:00+02:00","description":"Unity es un contenedor de inyecci&oacute;n de dependencias que facilita el desarrollo de aplicaciones proporcionando un sistema para gestionar tanto la construcci&oacute;n de objetos como las dependencias entre los diferentes componentes de una aplicaci&oacute;n. Supongamos que hemos definido&nbsp; un interface a trav&eacute;s del cual gestionaremos todo el sistema de registro de eventos de nuestra aplicaci&oacute;n. &nbsp;&nbsp;&nbsp; public interface ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; void Log(string message); &nbsp;&nbsp;&nbsp; } &nbsp;Y a su vez una clase que implementa dicho interface y que en este caso simplemente enviara el mensaje a la consola del sistema. &nbsp;&nbsp;&nbsp; public class ConsoleLoggingService: ILoggingService &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public void Log(string message) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Console: &quot; + message); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;El funcionamiento b&aacute;sico del contenedor es sencillo, en primer lugar registraremos en el contenedor los tipos de objetos que deseamos que gestione. Al hacerlo, adem&aacute;s, indicaremos al contenedor cual debe ser el ciclo de vida del objetos de ese tipo. En el caso que nos ocupa registraremos el interface ILoggingService en el contenedor mapeando dicho interface al tipo ConsoleLoggingService de tal forma que cuando solicitemos al contenedor un objeto implementando el interface ILoggingService nos devuelva un objeto del tipo ConsoleLoggingService. Como adem&aacute;s deseamos que en la aplicaci&oacute;n solo exista una &uacute;nica instancia del sistema de eventos (Singleton), indicaremos al contenedor que se encargue de controlar la vida del objeto, de esta forma la primera vez que solicitemos el interface se crear&aacute; el objeto pero las veces sucesivas se nos devolvera una referencia al mismo objeto. El siguiente fragmento de c&oacute;digo muestra el proceso de registro utilizando uno de los m&eacute;todos que nos brinda el contenedor. &nbsp;&nbsp;&nbsp; IUnityContainer container = new UnityContainer(); &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); Veamos como funciona la inyecci&oacute;n de dependencias. El contenedor nos proporciona varias formas de realizar la inyecci&oacute;n de dependencias: a trav&eacute;s del constructor, a trav&eacute;s de una propiedad &oacute; a trav&eacute;s de un m&eacute;todo. En el caso general, las inyecci&oacute;n requiere que marquemos el constructor, la propiedad o el m&eacute;todo con un atributo que indicar&aacute; al contenedor que debe realizar la inyecci&oacute;n de un objeto. El siguiente fragmento de c&oacute;digo muestra la utilizaci&oacute;n del atributo InjectionConstructor para indicar al contenedor que debe inyectar un objeto con el interface ILoggingService a la hora de construir un objeto del tipo MainApplicationModule. &nbsp;&nbsp;&nbsp; public class MainApplicationModule &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ILoggingService mLoggingService; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [InjectionConstructor] &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public MainApplicationModule(ILoggingService loggingService) &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService = loggingService; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService.Log(&quot;Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n&quot;); &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } &nbsp;N&oacute;tese que en este caso, al existir solo un constructor, el contenedor inyectar&aacute; las dependencias en el constructor de forma aut&oacute;matica aunque no hayamos marcado el constructor, sin embargo, dicho atributo es &uacute;til para indicar que constructor utilizar en el caso de que existan varios. Si tenemos una clase con varios constructores y ninguno de ellos est&aacute; marcado con el atributo de inyecci&oacute;n, el contenedor utilizar&aacute; aquel que tenga m&aacute;s par&aacute;metros, lanzando una excepci&oacute;n en el caso de que exista m&aacute;s de un constructor que cumpla la propiedad de tener el m&aacute;ximo n&uacute;mero de par&aacute;metros. &nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) &nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; using (IUnityContainer container = new UnityContainer()) &nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; container.RegisterType&lt;ILoggingService, &nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ConsoleLoggingService&gt;(new ContainerControlledLifetimeManager()); &nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MainApplicationModule mainModule = container.Resolve&lt;MainApplicationModule&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Console.ReadLine(); &nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;En la linea 7 del anterior fragmento de c&oacute;digo, solicitamos al contenedor que nos devuelva un objeto del tipo MainApplicationModule. Obs&eacute;rvese que en este caso no ha sido necesario registrar el objeto con el contenedor previamente. La utilidad de crear un objeto a trav&eacute;s del contenedor de un tipo que no ha sido previamente registrado es que el contenedor evaluar&aacute; e inyectar&aacute; las dependencias de dicho objeto al generarle. Despu&eacute;s de la ejecuci&oacute;n de la linea 7 aparecer&aacute; en la consola del sistema la siguiente l&iacute;nea indicando que se ha realizado el proceso de inyecci&oacute;n de la dependencia ILoggingService correctamente: Console: Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n Las ventajas de la utilizacion del patron de dise&ntilde;o de inyecci&oacute;n de dependencias se hacen evidentes a m&eacute;dida que el n&uacute;mero de componentes de la aplicaci&oacute;n aumenta, permitiendonos mantener un acoplamiento d&eacute;bil entre dichos componentes y facilitando el mantenimiento posterior de la aplicaci&oacute;n al unificar el sistema de construcci&oacute;n y cableado de objetos. Puede que surja la pregunta de que tipo de objetos debemos instanciar a trav&eacute;s del contenedor. En mi experiencia, los componentes que forman parte de la arquitectura o flujo principal de la aplicaci&oacute;n, esto es, servicios, vistas, presentadores, m&oacute;delos, etc, son buenos candidatos para ser incluidos en el contenedor. Finalizaremos este art&iacute;culo enumerando dos ventajas instantaneas de utilizar un contenedor para estructurar nuestra aplicaci&oacute;n: Si en lugar de mostrar los eventos del sistema por la consola decidimos registrarles en una base de datos, podr&iacute;amos definir un nuevo tipo DatabaseLoggingService implementando el interface ILoggingService y registrar dicho tipo en lugar de ConsoleLoggingService. Con esa sencilla modificaci&oacute;n la aplicaci&oacute;n pasar&iacute;a a registrar los eventos en una base de datos.El contenedor introduce el concepto de &#39;cadena de montaje&#39; y nos permite extender las acciones a realizar a la hora de crear un objeto. Un uso t&iacute;pico es el &#39;EventBroker&#39; o sistema de gesti&oacute;n de eventos que permite marcar eventos de los tipos con el atributo de publicaci&oacute;n y m&eacute;todos con el atributo de suscripci&oacute;n, encargandose el contenedor a la hora de construir los objetos de cablear los publicadores con los suscriptores facilitando la implementaci&oacute;n del patron de dise&ntilde;o observador. &nbsp;","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="la ciudadela" /><script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">la ciudadela</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Introducción al contenedor Unity</h1>
  </header>

  <div class="post-content">
    <p><a id="tc:e" href="http://www.codeplex.com/unity" target="_blank" title="Unity">Unity</a> es un contenedor de <a id="zv_7" href="http://es.wikipedia.org/wiki/Inyecci%C3%B3n_de_dependencias" target="_blank" title="inyecci&oacute;n de dependencias">inyecci&oacute;n de dependencias</a> que facilita el desarrollo de aplicaciones proporcionando un sistema para gestionar tanto la construcci&oacute;n de objetos como las dependencias entre los diferentes componentes de una aplicaci&oacute;n.</p>
<p>Supongamos que hemos definido&nbsp; un interface a trav&eacute;s del cual gestionaremos todo el sistema de registro de eventos de nuestra aplicaci&oacute;n.</p>
<div id="e_3w" style="background: white none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; font-family: Consolas; color: black;"><div id="hzms" style="background: white none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; font-family: Consolas; color: black;"><p id="utms" style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span id="q-va" style="color: blue;">public</span> <span id="ipcs" style="color: blue;">interface</span> <span id="lo3v" style="color: rgb(43, 145, 175);">ILoggingService</span></p> <p id="ef5d" style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p> <p id="xpqp" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="j4j1" style="color: blue;">void</span> Log(<span id="b3e-" style="color: blue;">string</span> message);</p> <p id="ph0." style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p></div></div>
<p>&nbsp;Y a su vez una clase que implementa dicho interface y que en este caso simplemente enviara el mensaje a la consola del sistema.</p>
<div style="background: white none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; font-family: Consolas; color: black;" id="q7qe"><p style="margin: 0px;" id="e2cz">&nbsp;&nbsp;&nbsp; <span style="color: blue;" id="t0ce">public</span> <span style="color: blue;" id="ekaf">class</span> <span style="color: rgb(43, 145, 175);" id="ixra">ConsoleLoggingService</span>: <span style="color: rgb(43, 145, 175);" id="cy4c">ILoggingService</span></p> <p style="margin: 0px;" id="maxh">&nbsp;&nbsp;&nbsp; {</p> <p style="margin: 0px;" id="l1je">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;" id="lo_a">public</span> <span style="color: blue;" id="eal7">void</span> Log(<span style="color: blue;" id="tiua">string</span> message)</p> <p style="margin: 0px;" id="icme">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p> <p style="margin: 0px;" id="rh9h">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: rgb(43, 145, 175);" id="zq91">Console</span>.WriteLine(<span style="color: rgb(163, 21, 21);" id="po0y">&quot;Console: &quot;</span> + message);</p> <p style="margin: 0px;" id="ou_0">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px;" id="cdav">&nbsp;&nbsp;&nbsp; }</p></div>
<p>&nbsp;El funcionamiento b&aacute;sico del contenedor es sencillo, en primer lugar registraremos en el contenedor los tipos de objetos que deseamos que gestione. Al hacerlo, adem&aacute;s, indicaremos al contenedor cual debe ser el ciclo de vida del objetos de ese tipo. En el caso que nos ocupa registraremos el interface <font color="#3d85c6" id="qnr:">ILoggingService</font> en el contenedor mapeando dicho interface al tipo <font color="#3d85c6" id="k5ow">ConsoleLoggingService</font> de tal forma que cuando solicitemos al contenedor un objeto implementando el interface <font color="#3d85c6" id="beut">ILoggingService</font> nos devuelva un objeto del tipo<font color="#3d85c6" id="dpf-"> ConsoleLoggingService</font>. Como adem&aacute;s deseamos que en la aplicaci&oacute;n solo exista una &uacute;nica instancia del sistema de eventos (<a title="Singleton" target="_blank" href="http://es.wikipedia.org/wiki/Singleton" id="ch_b">Singleton</a>), indicaremos al contenedor que se encargue de controlar la vida del objeto, de esta forma la primera vez que solicitemos el interface se crear&aacute; el objeto pero las veces sucesivas se nos devolvera una referencia al mismo objeto. El siguiente fragmento de c&oacute;digo muestra el proceso de registro utilizando uno de los m&eacute;todos que nos brinda el contenedor.</p>
<div id="ts.i" style="background: white none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; font-family: Consolas; color: black;"><div id="ys2e" style="background: white none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; font-family: Consolas; color: black;"><p id="g5vz" style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span id="ecjs" style="color: rgb(43, 145, 175);">IUnityContainer</span> container = <span id="dzoo" style="color: blue;">new</span> <span id="r5rj" style="color: rgb(43, 145, 175);">UnityContainer</span>();</p> <p id="spqi" style="margin: 0px;">&nbsp;&nbsp;&nbsp; container.RegisterType&lt;<span id="w0zw" style="color: rgb(43, 145, 175);">ILoggingService</span>,</p> <p id="ph-g" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="vo9o" style="color: rgb(43, 145, 175);">ConsoleLoggingService</span>&gt;(<span id="p6tj" style="color: blue;">new</span> <span id="e2:6" style="color: rgb(43, 145, 175);">ContainerControlledLifetimeManager</span>());</p></div></div>
<p>Veamos como funciona la inyecci&oacute;n de dependencias. El contenedor nos proporciona varias formas de realizar la inyecci&oacute;n de dependencias: a trav&eacute;s del constructor, a trav&eacute;s de una propiedad &oacute; a trav&eacute;s de un m&eacute;todo. En el caso general, las inyecci&oacute;n requiere que marquemos el constructor, la propiedad o el m&eacute;todo con un atributo que indicar&aacute; al contenedor que debe realizar la inyecci&oacute;n de un objeto. El siguiente fragmento de c&oacute;digo muestra la utilizaci&oacute;n del atributo <font color="#3d85c6" id="f.dg">InjectionConstructor</font> para indicar al contenedor que debe inyectar un objeto con el interface <font color="#3d85c6" id="i3cy">ILoggingService</font> a la hora de construir un objeto del tipo <font color="#3d85c6" id="yqcg">MainApplicationModule</font>.</p>
<div id="bisa" style="background: white none repeat scroll 0% 50%; font-family: Consolas; font-size: 10pt; color: black; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><p id="t_.6" style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span id="mhm7" style="color: blue;">public</span> <span id="c.9." style="color: blue;">class</span> <span id="cw-x" style="color: rgb(43, 145, 175);">MainApplicationModule</span></p> <p id="fjau" style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p> <p id="oi5l" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="hs03" style="color: rgb(43, 145, 175);">ILoggingService</span> mLoggingService;</p> <p id="c4wa" style="margin: 0px;">&nbsp;</p> <p id="xllo" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [<span id="ot.d" style="color: rgb(43, 145, 175);">InjectionConstructor</span>]</p> <p id="te4r" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="es0y" style="color: blue;">public</span> MainApplicationModule(<span id="kb6b" style="color: rgb(43, 145, 175);">ILoggingService</span> loggingService)</p> <p id="jpj1" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p> <p id="eu-9" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService = loggingService;</p> <p id="p5ws" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mLoggingService.Log(<span id="qa4_" style="color: rgb(163, 21, 21);">&quot;Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n&quot;</span>);</p> <p id="wab:" style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p> <p id="wjtu" style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p></div>
<p>&nbsp;N&oacute;tese que en este caso, al existir solo un constructor, el contenedor inyectar&aacute; las dependencias en el constructor de forma aut&oacute;matica aunque no hayamos marcado el constructor, sin embargo, dicho atributo es &uacute;til para indicar que constructor utilizar en el caso de que existan varios. Si tenemos una clase con varios constructores y ninguno de ellos est&aacute; marcado con el atributo de inyecci&oacute;n, el contenedor utilizar&aacute; aquel que tenga m&aacute;s par&aacute;metros, lanzando una excepci&oacute;n en el caso de que exista m&aacute;s de un constructor que cumpla la propiedad de tener el m&aacute;ximo n&uacute;mero de par&aacute;metros.</p>
<div id="ohsk" style="background: white none repeat scroll 0% 50%; font-family: Consolas; font-size: 10pt; color: black; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><p id="zy11" style="margin: 0px;"><span id="lfp_" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;1</span>&nbsp;&nbsp;&nbsp;&nbsp; <span id="uzue" style="color: blue;">static</span> <span id="omwh" style="color: blue;">void</span> Main(<span id="dd5j" style="color: blue;">string</span>[] args)</p> <p id="e2b4" style="margin: 0px;"><span id="er3." style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;2</span>&nbsp;&nbsp;&nbsp;&nbsp; {</p> <p id="tjx7" style="margin: 0px;"><span id="lj72" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;3</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="shah" style="color: blue;">using</span> (<span id="jhqj" style="color: rgb(43, 145, 175);">IUnityContainer</span> container = <span id="n75m" style="color: blue;">new</span> <span id="h7s4" style="color: rgb(43, 145, 175);">UnityContainer</span>())</p> <p id="vpcx" style="margin: 0px;"><span id="w-gj" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;4</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p> <p id="ar84" style="margin: 0px;"><span id="kyq5" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;5</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; container.RegisterType&lt;<span id="ooxw" style="color: rgb(43, 145, 175);">ILoggingService</span>,</p> <p id="xxhe" style="margin: 0px;"><span id="al7e" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;6</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="t98d" style="color: rgb(43, 145, 175);">ConsoleLoggingService</span>&gt;(<span id="d::a" style="color: blue;">new</span> <span id="h1m." style="color: rgb(43, 145, 175);">ContainerControlledLifetimeManager</span>());</p> <p id="huku" style="margin: 0px;"><span id="vmso" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;7</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="ul:s" style="color: rgb(43, 145, 175);">MainApplicationModule</span> mainModule = container.Resolve&lt;<span id="xbvk" style="color: rgb(43, 145, 175);">MainApplicationModule</span>&gt;();</p> <p id="u4.t" style="margin: 0px;"><span id="h9jh" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;8</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span id="a.xi" style="color: rgb(43, 145, 175);">Console</span>.ReadLine();</p> <p id="cs8z" style="margin: 0px;"><span id="g5wy" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;&nbsp;9</span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p> <p id="l06z" style="margin: 0px;"><span id="k7ku" style="color: rgb(43, 145, 175);">&nbsp;&nbsp;&nbsp;10</span>&nbsp;&nbsp;&nbsp;&nbsp; }</p></div>
<p>&nbsp;En la linea 7 del anterior fragmento de c&oacute;digo, solicitamos al contenedor que nos devuelva un objeto del tipo <font color="#3d85c6" id="x25h">MainApplicationModule</font>. Obs&eacute;rvese que en este caso no ha sido necesario registrar el objeto con el contenedor previamente. La utilidad de crear un objeto a trav&eacute;s del contenedor de un tipo que no ha sido previamente registrado es que el contenedor evaluar&aacute; e inyectar&aacute; las dependencias de dicho objeto al generarle.</p>
<p>Despu&eacute;s de la ejecuci&oacute;n de la linea 7 aparecer&aacute; en la consola del sistema la siguiente l&iacute;nea indicando que se ha realizado el proceso de inyecci&oacute;n de la dependencia <font color="#3d85c6" id="z:e_">ILoggingService</font> correctamente:</p>
<p><font color="#ffffff" id="h30."><span id="l6bp" style="background-color: rgb(0, 0, 0);">Console: Inicializado el m&oacute;dulo principal de la aplicaci&oacute;n</span></font></p>
<p>Las ventajas de la utilizacion del patron de dise&ntilde;o de inyecci&oacute;n de dependencias se hacen evidentes a m&eacute;dida que el n&uacute;mero de componentes de la aplicaci&oacute;n aumenta, permitiendonos mantener un acoplamiento d&eacute;bil entre dichos componentes y facilitando el mantenimiento posterior de la aplicaci&oacute;n al unificar el sistema de construcci&oacute;n y cableado de objetos.</p>
<p>Puede que surja la pregunta de que tipo de objetos debemos instanciar a trav&eacute;s del contenedor. En mi experiencia, los componentes que forman parte de la arquitectura o flujo principal de la aplicaci&oacute;n, esto es, servicios, vistas, presentadores, m&oacute;delos, etc, son buenos candidatos para ser incluidos en el contenedor.</p>
<p>Finalizaremos este art&iacute;culo enumerando dos ventajas instantaneas de utilizar un contenedor para estructurar nuestra aplicaci&oacute;n:</p>
<ol id="e00v"><li id="fh8c">Si en lugar de mostrar los eventos del sistema por la consola decidimos registrarles en una base de datos, podr&iacute;amos definir un nuevo tipo <font color="#3d85c6" id="s0_.">DatabaseLoggingService</font> implementando el interface <font color="#3d85c6" id="krxh">ILoggingService</font> y registrar dicho tipo en lugar de <font color="#3d85c6" id="pgad">ConsoleLoggingService</font>. Con esa sencilla modificaci&oacute;n la aplicaci&oacute;n pasar&iacute;a a registrar los eventos en una base de datos.</li><li id="fh8c">El contenedor introduce el concepto de 'cadena de montaje' y nos permite extender las acciones a realizar a la hora de crear un objeto. Un uso t&iacute;pico es el 'EventBroker' o sistema de gesti&oacute;n de eventos que permite marcar eventos de los tipos con el atributo de publicaci&oacute;n y m&eacute;todos con el atributo de suscripci&oacute;n, encargandose el contenedor a la hora de construir los objetos de cablear los publicadores con los suscriptores facilitando la implementaci&oacute;n del patron de dise&ntilde;o <a title="observador" target="_blank" href="http://es.wikipedia.org/wiki/Observer_%28patr%C3%B3n_de_dise%C3%B1o%29" id="i_hu">observador</a>.</li></ol>
<p>&nbsp;</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">la ciudadela</h2>
        <ul class="contact-list">
          <li class="p-name">peancor</li></ul>
      </div>

      <div class="footer-col one-half">
        <p>Blog personal de Pedro Anuarbe Cortes (@peancor)
</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://twitter.com/peancor" title="peancor"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
